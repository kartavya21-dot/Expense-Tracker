# Frontend Vulnerability and Improvement Report

This document outlines the security vulnerabilities, coding mistakes, and suggestions for improvement for the React frontend of the Workout Tracker application.

## 1. Security Vulnerabilities

### 1.1. Hardcoded Backend URL
- **File:** `Frontend/Expense Tracker/src/components/Tracker/Tracker.jsx`
- **Vulnerability:** The backend API URL (`http://localhost:8000/api/tracker/`) is hardcoded directly in the component. This is inflexible and insecure.
- **Impact:**
    - **Inflexibility:** To change the API endpoint (e.g., for production), you must modify the source code and rebuild the application.
    - **Information Leakage:** It exposes the development environment's structure.
- **Recommendation:** Store the API URL in an environment variable. Create a `.env` file in the `Frontend/Expense Tracker` directory and add `VITE_API_BASE_URL=http://localhost:8000/api`. Access it in your code using `import.meta.env.VITE_API_BASE_URL`.

### 1.2. Lack of Input Validation
- **File:** `Frontend/Expense Tracker/src/components/Tracker/Tracker.jsx`
- **Vulnerability:** The form fields for `title` and `price` have no client-side validation before being sent to the backend.
- **Impact:** Users can submit empty or invalid data (e.g., a negative price), which can lead to corrupted data in the database or cause the backend to throw errors. While the backend should always have its own validation, client-side validation provides a better user experience and a first line of defense.
- **Recommendation:** Before calling `handleSubmit`, validate that `title` is not empty and that `price` is a positive number. Disable the submit button until the form is valid.

## 2. Mistakes and Bad Practices

These are issues that deviate from best practices and can lead to bugs, poor user experience, and maintenance problems.

### 2.1. No Error Handling for Users
- **File:** `Frontend/Expense Tracker/src/components/Tracker/Tracker.jsx`
- **Mistake:** All API call errors (`axios.post`, `axios.get`, `axios.delete`) are only logged to the console (`console.log(e)`). The user receives no feedback if an action fails.
- **Impact:** If an expense fails to save or delete, the user will not know. The UI might appear to have worked, leading to data inconsistency and a confusing user experience.
- **Recommendation:**
    - Create a state variable for errors (e.g., `const [error, setError] = useState(null)`).
    - In the `catch` blocks of your API calls, set an appropriate error message (`setError("Failed to add expense. Please try again.")`).
    - Display the error message to the user in the UI.

### 2.2. No Loading State Indicators
- **File:** `Frontend/Expense Tracker/src/components/Tracker/Tracker.jsx`
- **Mistake:** The application does not provide any visual feedback while data is being fetched, created, or deleted.
- **Impact:** On a slow network, the application will feel unresponsive. The user might click a button multiple times, thinking the first click didn't register, leading to duplicate requests.
- **Recommendation:**
    - Use a loading state (e.g., `const [isLoading, setIsLoading] = useState(false)`).
    - Set `setIsLoading(true)` before an API call and `setIsLoading(false)` after it completes (in both `then` and `catch` blocks).
    - Use this state to show a loading spinner or disable buttons to prevent multiple submissions.

### 2.3. Inefficient State Updates and Re-fetching
- **File:** `Frontend/Expense Tracker/src/components/Tracker/Tracker.jsx`
- **Mistake:** After creating or deleting an expense, the entire list of expenses is re-fetched from the server (`fetchExpense("", "")`).
- **Impact:** This is inefficient and causes unnecessary network traffic and backend load, especially as the list of expenses grows.
- **Recommendation:**
    - **On Create:** After a successful `axios.post`, the backend should return the newly created expense. Update the local state by appending this new item to the existing `expenses` array: `setExpense(prevExpenses => [newExpense, ...prevExpenses])`.
    - **On Delete:** After a successful `axios.delete`, update the local state by filtering out the deleted item: `setExpense(prevExpenses => prevExpenses.filter(item => item.id !== expense.id))`.

### 2.4. Uncontrolled Component Warning
- **File:** `Frontend/Expense Tracker/src/components/Tracker/Tracker.jsx`
- **Mistake:** The `category` state is initialized as an empty string (`""`) but the `handleCategory` function receives the event object `e` and sets the state to it. This is likely a bug. The intention seems to be to set the category from the button's text content.
- **Recommendation:** The `handleCategory` function should be `const handleCategory = (item) => { setCategory(item) }` and the button's `onClick` should be `onClick={() => handleCategory(item)}`.

### 2.5. Incorrect Sorting Logic
- **File:** `Frontend/Expense Tracker/src/components/Tracker/Tracker.jsx`
- **Mistake:** The sorting logic is reversed. `sortNewest` passes `?ordering=created_at`, which typically means ascending (oldest first). `sortOldest` passes `?ordering=-created_at`, which means descending (newest first).
- **Recommendation:** Swap the query parameters in the `sortNewest` and `sortOldest` functions to match their names.
    - `sortNewest` -> `fetchExpense("?ordering=-created_at", "")`
    - `sortOldest` -> `fetchExpense("?ordering=created_at", "")`

## 3. Suggestions for Improvement

### 3.1. Component Structure
- **File:** `Frontend/Expense Tracker/src/components/Tracker/Tracker.jsx`
- **Suggestion:** The `Tracker.jsx` component is a monolithic component responsible for state management, data fetching, and rendering the form, filters, and expense list. This makes it difficult to maintain and test.
- **Recommendation:** Break down the UI into smaller, reusable components:
    - `ExpenseForm.jsx`: Manages the form inputs and submission.
    - `ExpenseList.jsx`: Renders the list of expenses.
    - `ExpenseItem.jsx`: Renders a single expense card.
    - `FilterControls.jsx`: Manages sorting and filtering UI.
    - Lift the state up to the parent `Tracker.jsx` component or use a state management library.

### 3.2. Use a UI Library
- **Suggestion:** The project uses custom CSS (`button-41`, etc.). While fine for small projects, a UI component library can provide accessible, consistent, and professionally designed components out-of-the-box.
- **Recommendation:** Consider using a library like Material-UI, Chakra UI, or Mantine to speed up development and improve the UI/UX.

### 3.3. Implement Frontend Testing
- **File:** `package.json`
- **Suggestion:** There are no dependencies or scripts for running tests.
- **Recommendation:** Add a testing framework like Vitest or React Testing Library to write unit and integration tests for your components. This ensures that UI components render correctly and that user interactions work as expected.
